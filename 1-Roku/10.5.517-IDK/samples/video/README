Copyright 2021 Roku, Inc.  All rights reserved.

This sample channel demonstrates:

+ How to build and use third-party libraries, in this case, FFMPEG.

+ How to use Roku's elementary stream video playback APIs.  In this sample, we
  use FFMPEG's libavformat APIs to parse audio and video files and extract
  elementary streams.  Please see buffer.cpp for implementation details.  Roku's
  player only supports two containers (PES and TS); however, using FFMPEG you
  can demux other containers and just send ES for playback.  FFMPEG also
  supports other protocols, so you should be able to play most videos URIs.

+ Register callback function to be notified when we reach end-of-stream.

The lesson to take away in no particular order:

+ When it is time to exit your channel, process will receive SIGTERM.  In
  main.cpp we install a signal handler and stop video playback when channel
  receives SIGTERM.

+ Initially when you start your channel, firmware will paint opaque black over
  graphics plane.  Graphics plane must be cleared before user can see video.

+ The test streams are generated using `ffmpeg` utility from a pre-recorded
  file.  The command line to generate video is:

    ffmpeg -i fishtank.mkv -an -c:v libx264 -r 30 -vf format=yuv420p
           -profile:v baseline -level:v 4.0 -b:v 1000k -movflags +faststart
	   -avoid_negative_ts make_zero -f vob streams/video.mp4

  for audio:

    ffmpeg -i fishtank.mkv -vn -c:a aac -b:a 96k
           -af "afade=t=in:ss=0:d=13" -avoid_negative_ts make_zero
           -f mpegts streams/audio.ts

  These command lines above give me two separate files with the codec
  I want, that libavformat will be able to extract PTS, and we ship a
  reasonable sized clip that isn't too short.  Of course, you can use
  libavformat to experiment with other protocols and containers supported,
  dynamically set audio and video ES codec to playback content from wide
  variety of sources.

+ To figure out resolution of display attached to your Roku device, we use
  BrightScript component roDeviceInfo.  Once we collect the information we
  want, we can pass that information as part of the launch parameters.  see
  main.brs for more details.

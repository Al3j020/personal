/*
 * Copyright (c) 2015-2020 Roku, Inc. All rights reserved.
 * This software and any compilation or derivative thereof is,
 * and shall remain, the proprietary information of Roku, Inc. and
 * is highly confidential in nature. Reproduction in whole or in part
 * is prohibited without the prior written consent of Roku, Inc.
 *
 * Under no circumstance may this software or any derivative thereof be
 * combined with any third party software, including open source software,
 * without the written permission of the Copyright owner.
 */
#ifndef ROKU_INPUT_H
#define ROKU_INPUT_H

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>

/*
  Types of events.
 */
enum {
    ROKU_INPUT_EVENT_TYPE_INVALID         = -1,
    ROKU_INPUT_EVENT_TYPE_BUTTON_RELEASED = 0,
    ROKU_INPUT_EVENT_TYPE_BUTTON_PRESSED  = 1,
    ROKU_INPUT_EVENT_TYPE_POINTER         = 2,
    ROKU_INPUT_EVENT_TYPE_MOTION          = 3,
    ROKU_INPUT_EVENT_TYPE_KEY_RELEASED    = 4,
    ROKU_INPUT_EVENT_TYPE_KEY_PRESSED     = 5
};

/*
  Sources of events.
 */
enum {
    ROKU_INPUT_SOURCE_TYPE_IR_REMOTE       = 0,
    ROKU_INPUT_SOURCE_TYPE_BT_CONTROLLER   = 1,
};

/*
  Buttons.
*/
enum {
    ROKU_INPUT_BUTTON_INVALID           =  0x00000000,
    ROKU_INPUT_BUTTON_UP                =  0x00000001,
    ROKU_INPUT_BUTTON_DOWN              =  0x00000002,
    ROKU_INPUT_BUTTON_LEFT              =  0x00000004,
    ROKU_INPUT_BUTTON_RIGHT             =  0x00000008,
    ROKU_INPUT_BUTTON_SELECT            =  0x00000010,
    ROKU_INPUT_BUTTON_PLAY              =  0x00000020,
    ROKU_INPUT_BUTTON_RWD               =  0x00000040,
    ROKU_INPUT_BUTTON_FWD               =  0x00000080,
    ROKU_INPUT_BUTTON_BACK              =  0x00000100,
    ROKU_INPUT_BUTTON_INFO              =  0x00000200,
    ROKU_INPUT_BUTTON_INSTANT_REPLAY    =  0x00000400,
    ROKU_INPUT_BUTTON_A                 =  0x00000800,
    ROKU_INPUT_BUTTON_B                 =  0x00001000,
    ROKU_INPUT_BUTTON_PLAY_ONLY         =  0x00002000,
    ROKU_INPUT_BUTTON_STOP              =  0x00004000,
    ROKU_INPUT_BUTTON_ENTER             =  0x00008000,
    ROKU_INPUT_BUTTON_BACKSPACE         =  0x00010000,
    ROKU_INPUT_BUTTON_PARTNER           =  0x00020000, /* This is always your partner button (if you have one) */
    ROKU_INPUT_BUTTON_RED               =  0x00040000,
    ROKU_INPUT_BUTTON_GREEN             =  0x00080000,
    ROKU_INPUT_BUTTON_YELLOW            =  0x00100000,
    ROKU_INPUT_BUTTON_BLUE              =  0x00200000,
    ROKU_INPUT_BUTTON_CHANNELUP         =  0x00400000,
    ROKU_INPUT_BUTTON_CHANNELDOWN       =  0x00800000,
    ROKU_INPUT_BUTTON_EXIT              =  0x01000000,
    ROKU_INPUT_BUTTON_GUIDE             =  0x02000000,
    ROKU_INPUT_BUTTON_PAUSE             =  0x04000000,
    ROKU_INPUT_BUTTON_LAST_CHANNEL      =  0x08000000,
};

/*
  Motion modes. Default is OFF.
*/
enum {
    ROKU_INPUT_MOTION_MODE_OFF     = 0,
    ROKU_INPUT_MOTION_MODE_STANDBY = 1,
    ROKU_INPUT_MOTION_MODE_ON      = 2
};

/*
  Pointer Ballistics types. Default is NON_LINEAR.
*/
enum {
    ROKU_INPUT_POINTER_BALLISTICS_LINEAR    = 0,
    ROKU_INPUT_POINTER_BALLISTICS_NON_LINEAR = 1
};

/*
  Connection state.

  NONE means there is no BT remote paired at the given index (the
  controller number passed to getControllerState().

  PAIRED means there is a remote paired but it is not actively
  connected.

  ACTIVE means the remote is paired and connected.
*/
enum {
    ROKU_INPUT_BT_CONNECTION_NONE    =  0,
    ROKU_INPUT_BT_CONNECTION_PAIRED  =  1,
    ROKU_INPUT_BT_CONNECTION_ACTIVE  =  2,
};

/*
  Context filters. Filters can alter or restrict the event
  flow, or mask out buttons on the controller.

  NONE is the default, and means that all events generated by
  the hardware are delivered, and no buttons are masked.

  ONE_DIRECTIONAL_BUTTON will restrict the event flow and
  button state to at most one directional button (UP, DOWN,
  LEFT, or RIGHT). While one of these buttons is pressed, all
  other directional button presses will be masked.
 */
enum {
    ROKU_CONTEXT_FILTER_NONE                   = 0x00000000,
    ROKU_CONTEXT_FILTER_ONE_DIRECTIONAL_BUTTON = 0x00000001
};


/*
  Claim or release Info button.
*/
enum {
    ROKU_CONTEXT_NOT_CLAIMED = 0,
    ROKU_CONTEXT_CLAIMED     = 1
};

struct RokuInputEvent;
typedef struct RokuInputEvent RokuInputEvent;

struct RokuController;
typedef struct RokuController RokuController;

struct RokuControllerState;
typedef struct RokuControllerState RokuControllerState;

struct RokuInputContext;
typedef struct RokuInputContext RokuInputContext;

/*
  **************************************
  *** RokuControllerState
  **************************************
*/

/*
  Sample is the same as the sample in the event. It increases
  every time the state changes. It's possible for it to rollover.
*/
uint32_t RokuControllerState_getSample(RokuControllerState *s);

/*
  buttons is a mask of the state of all of the buttons where 0 means
  not pressed and 1 means pressed. Use the BUTTON masks above to test
  for each button.  example if (buttons & ROKU_INPUT_BUTTON_DOWN)
 */
uint32_t RokuControllerState_getButtons(RokuControllerState *s);

/*
  Get the current connection state of the remote. Returns one of
  ROKU_INPUT_BT_CONNECTION_* described above.
*/
uint8_t RokuControllerState_getConnectionState(RokuControllerState *s);

/*
  Release an event retrieved via RokuInputContext_getControllerState().
 */
void RokuControllerState_release(RokuControllerState *s);

/*
  **************************************
  *** RokuInputEvent
  **************************************
*/

/*
  Returns one of ROKU_INPUT_EVENT_TYPE_*.
 */
int32_t RokuInputEvent_getType(RokuInputEvent *e);

/*
  Returns one of ROKU_INPUT_SOURCE_TYPE_*.
 */
int32_t RokuInputEvent_getSource(RokuInputEvent *e);

/*
  Get the controller number that generated this event.
  Returns 0 or 1 or -1 if an error occurred.
 */
int32_t RokuInputEvent_getController(RokuInputEvent *e);

/*
  Returns one of ROKU_INPUT_BUTTON_*
 */
int32_t RokuInputEvent_getButton(RokuInputEvent *e);

/*
  Returns unicode key code. Valid when type
  is ROKU_INPUT_EVENT_TYPE_KEY_*.

  The value returned is always >= 0x20. < 0x20 are mostly irrelevant
  control characters. Relevant control characters like backspace are
  treated as buttons. See ROKU_INPUT_BUTTON_BACKSPACE and
  ROKU_INPUT_BUTTON_ENTER.
 */
int32_t RokuInputEvent_getKey(RokuInputEvent *e);

/*
  Get the absolute x and y pointer values.
  Only valid for ROKU_INPUT_EVENT_TYPE_POINTER.
 */
int32_t RokuInputEvent_getPointerX(RokuInputEvent *e);
int32_t RokuInputEvent_getPointerY(RokuInputEvent *e);

/*
  Get the delta x and y pointer values.
  Only valid for ROKU_INPUT_EVENT_TYPE_POINTER.
 */
int32_t RokuInputEvent_getDeltaX(RokuInputEvent *e);
int32_t RokuInputEvent_getDeltaY(RokuInputEvent *e);

/*
  Get linear acceleration with and without gravity.
  Returns array with 3 floats. (x,y,z) meters/sec squared
  Only valid for ROKU_INPUT_EVENT_TYPE_MOTION.
 */
float* RokuInputEvent_getLinAcc(RokuInputEvent *e);
float* RokuInputEvent_getLinAccNoGravity(RokuInputEvent *e);

/*
  Get angular velocity.
  Returns array with 3 floats. (x,y,z) radions/sec.
  Only valid for ROKU_INPUT_EVENT_TYPE_MOTION.
 */
float* RokuInputEvent_getAngVel(RokuInputEvent *e);

/*
  Get angular position.
  Returns quarternion array with 4 floats. (w,x,y,z)
  Only valid for ROKU_INPUT_EVENT_TYPE_MOTION.
 */
float* RokuInputEvent_getAngPos(RokuInputEvent *e);

/*
  Get the sample number. This is simply a number
  that is incremented for each event. It will rollover
*/
uint32_t RokuInputEvent_getSample(RokuInputEvent *e);

/*
  Each event is timestamped with a monotonically increasing 64 bit
  unsigned integer that represents number of ms from some time in the
  past. This is only intended to be used to compare against other
  events.

  This is DEPRECATED for motion and pointer events. In fact it always
  returns 0 for motion and pointer events because it has a CPU cost
  that is not warranted for the possible utility it might provide. It
  was mostly intended for debugging, etc.
*/
uint64_t RokuInputEvent_getTimestamp(RokuInputEvent *e);

RokuInputEvent *RokuInputEvent_createButtonKeyEvent(
    uint64_t timestamp,
    uint32_t sample,
    int16_t  source,
    int16_t  type,
    int16_t  controller,
    int32_t  button);
/*
  Release an event retrieved via RokuInputContext_getEvent().
 */
void RokuInputEvent_release(RokuInputEvent *e);

/*
  **************************************
  *** RokuController
  **************************************
*/

/*
  Same as RokuInputContext_getControllerState except on the
  RokuController type.
 */
int32_t RokuController_getState(RokuController *c, RokuControllerState **outState);

/*
  set/get the motion mode.
  One of ROKU_INPUT_MOTION_MODE_*
  Returns 0 on success. Non-zero on error.
*/
int32_t RokuController_setMotionMode(RokuController *c, int32_t mode);
int32_t RokuController_getMotionMode(RokuController *c, int32_t *mode);

/*
  set/get the pointer gain. 1.0 is the default. Values greater
  than 1.0 increase the gain and thus make the pointer movement
  more sensitive. Values less than 1.0 decrease the sensitivity.
  Returns 0 on success. Non-zero on error.
*/
int32_t RokuController_setPointerGain(RokuController *c, float gain);
int32_t RokuController_getPointerGain(RokuController *c, float *gain);

/*
  set/get the pointer ballistics.
  One of ROKU_INPUT_POINTER_BALLISTICS_*
  Returns 0 on success. Non-zero on error.
*/
int32_t RokuController_setPointerBallistics(RokuController *c, int32_t ballistics);
int32_t RokuController_getPointerBallistics(RokuController *c, int32_t *ballistics);

/*
  set/get the motion output rate. The rate is the number of events
  output per second. The default is the max. Call getMotionOutputRate()
  to determine the max. Setting values smaller than the default can
  utilize fewer cpu resources. A rate of 0 is accepted but the
  real minimum is 1 as 1 sample per second will still be output.

  Returns 0 on success. Non-zero on error.
*/
int32_t RokuController_setMotionOutputRate(RokuController *c, uint32_t rate);
int32_t RokuController_getMotionOutputRate(RokuController *c, uint32_t *rate);

/*
  Forces the current pointer location to the given screen coordinates.
  0,0 is in the upper left.
  Returns 0 on success. Non-zero on error.
*/
int32_t RokuController_setPointerLocation(RokuController *c, int16_t x, int16_t y);

/*
  Restore all default configuration values.
  Returns 0 on success. Non-zero on error.
*/
int32_t RokuController_restoreDefaults(RokuController *c);

/*
  Release a controller retrieved via RokuInputContext_getController().
 */
void RokuController_release(RokuController *c);

/*
  **************************************
  *** RokuInputContext
  **************************************
*/

/*
  Create a new RokuInputContext.  RokuInputContext_release must be
  called when the application is done using the context.

  Returns 0 if successful and -1 if an error occurs.
 */
int32_t RokuInputContext_create(RokuInputContext **c);

/*
  Create a new RokuInputContext with the specified filter.
  RokuInputContext_release must be called when the application is
  done using the context.

  Returns 0 if successful and -1 if an error occurs.
 */
int32_t RokuInputContext_createWithFilter(RokuInputContext **c, int32_t filter);

/*
  Release a RokuInputContext. The context can not be used after this
  function has been called.
 */
void RokuInputContext_release(RokuInputContext *c);

/*
  Returns 0 if there are no new events.
  Returns 1 if new events are available.

  RokuInputContext_hasEventsBlocking blocks until there is a new event
  available. The return values are the same. This may return 0 so the
  return value should be checked even in the blocking case.
 */
int32_t RokuInputContext_hasEvents(RokuInputContext *c);
int32_t RokuInputContext_hasEventsBlocking(RokuInputContext *c);

/*
  Get a new event from the context if a new event is available.

  Returns 3 if we're returning due to RokuInputContext_cancelEventBlocking()
               being called.
  Returns 2 if we're returning due to a timeout.
  Returns 1 if a new event was returned.
  Returns 0 if no new events are available.
  Returns a value < 0 if an error occurred.

  RokuInputContext_getEventBlocking blocks until there is a new event
  available. The return values are the same. This may return 0 so the
  return value should be checked even in the blocking case.

  If an event is returned, then it must be released with
  RokuInputEvent_release() when the application is done with it.

  The timeoutMs allows a timeout limit to be specified by the caller in units
  of milliseconds.  If the timeout value is 0, then the function will wait
  indefinitely until an event is received or until the wait is cancelled by
  a call to RokuInputContext_cancelEventBlocking().
 */
int32_t RokuInputContext_getEvent(RokuInputContext *c, RokuInputEvent **outEvent);
int32_t RokuInputContext_getEventBlocking(RokuInputContext *c,
                                          RokuInputEvent **outEvent,
                                          int32_t timeoutMs);

/*
 Cancels any waiting on RokuInputContext_getEventBlocking() which may be done
 by other threads.  The cancellation request will ensure that at least one
 RokuInputContext_getEventBlocking() call will return with the status 3
 indicating that it is responding to a cancellation.
 */
void RokuInputContext_cancelEventBlocking(RokuInputContext *c);

/*
  Get the current controller state for the given controller.

  Returns 1 if the state was successfully returned.
  Returns 0 if the controller index or the RokuInputContext is not valid.
  Returns a value < 0 if an error occurred.

  If the state is returned (1 is returned), then it must be released with
  RokuControllerState_release() when the application is done with it.
*/
int32_t RokuInputContext_getControllerState(RokuInputContext *c, int16_t controller,
                                            RokuControllerState **s);

/*
  Get the controller given the index. Use RokuController_ functions to inspect.

  Returns 1 if the controller was successfully returned.
  Returns 0 if the controller index or the RokuInputContext is not valid.
  Returns a value < 0 if an error occurred.

  If the controller is returned (1 is returned), then it must be released with
  RokuController_release() when the application is done with it.
*/
int32_t RokuInputContext_getController(RokuInputContext *i, int16_t controller,
                                       RokuController **c);

/*
  When playing full screen video, the firmware will handle the info button.
  (Left panel will slide in with Picture settings and so on on Roku TVs).
  This is required for certification. When there is a UI on top of full screen
  video, this UI may handle the info button instead. To receive events in that
  case call this function with ROKU_CONTEXT_CLAIMED. To go back to the default
  behavior call this function with ROKU_CONTEXT_NOT_CLAIMED.

  NOTES:
  This only applies to full screen video. In the non-full-screen case the Info
  button is not handled by the firmware.
  When an application gets suspended the state is set back to not claimed and
  this function will have to be called again.

  Returns 1 if successful
  Returns 0 if the RokuInputContext is not valid.
  Returns a value < 0 if an error occurred.

*/
int32_t RokuInputContext_claimInfoButton(RokuInputContext *c, int32_t claim);


#ifdef __cplusplus
}
#endif

#endif //ROKU_INPUT_H
